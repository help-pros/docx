
![](images/a.png)

![](images/b.png)

#  typora 快捷键

https://blog.csdn.net/SIMBA1949/article/details/79001226

- 无序列表：输入-之后输入空格
- 有序列表：输入数字+“.”之后输入空格
- 任务列表：-[空格]空格 文字
- 标题：ctrl+数字
- 表格：ctrl+t
- 生成目录：[TOC]按回车
- 选中一整行：ctrl+l
- 选中单词：ctrl+d
- 选中相同格式的文字：ctrl+e
- 跳转到文章开头：ctrl+home
- 跳转到文章结尾：ctrl+end
- 搜索：ctrl+f
- 替换：ctrl+h
- 引用：输入>之后输入空格
- 代码块：ctrl+alt+f
- 加粗：ctrl+b
- 倾斜：ctrl+i
- 下划线：ctrl+u
- 删除线：alt+shift+5
- 插入图片：直接拖动到指定位置即可或者ctrl+shift+i
- 插入链接：ctrl+k

## typora画流程图

https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html?qq-pf-to=pcqq.c2c

```mermaid
graph LR
F[横向流程图]
A[方形]-->B(圆角)
B-->C{条件a}
C-->|a=1|D[结果1]
C-->|a=2|E[结果2]
```

```mermaid
graph TD
A[方形]-->B(圆角)
B-->C{条件a}
C-->|a=1|D[结果1]
C-->|a=2|E[结果2]
F[竖向流程图]
```

```flow
st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框
st->op->cond
cond(yes)->io->e
cond(no)->sub1(right)->op
```





# EditPlus等编辑器的使用

## 选中列（块）的方法

> **EditPlus**** **
> 1）菜单：编辑 -> 选择 -> 列选择
> 2）先按下 Alt + C ，释放，然后移动鼠标或键盘上下左右键进行选择 
> 注意：在自动换行的模式下是不行的，改为不自动换行就行了。
>
>  
>
> **Notepad++**
>
> 1）按住 Alt 键，然后用鼠标进行选择 
> 2）按住 Alt + Shift 键，然后用箭头（键盘的上下左右箭头）进行选择
>
>  
>
> **UltraEdit**
>
> 1）菜单栏有一个列块乒乓开关图标，选中它然后就进入列/块选择模式 
> 2）按一下 Alt + C ，然后用鼠标或键盘进行选择 
>
>  
>
> **EmEditor**
>
> 需要按住 Alt + C ，然后同时用鼠标进行选择
>
>  
>
> **LiteEdit**
>
> 1）按住ALT键然后用鼠标进行列块选择
>
> 2）点击菜单上的"列块选择"后用鼠标进行列块选择



# maven（自动化构建工具）

 

![](images/maven.png)





 

目前技术在开发中存在的问题：（动态web项目）

a.       一个项目就是一个工程

（最好是每个模块对应一个工程，利于分工协作）

b.      项目中需要的jar包必须手动复制到WEB-INF/lib目录下

（带来的问题是：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿）

借助maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来

 

c.       jar包需要官网下载

d.      一个jar包依赖的其它jar包需要自己手动加入到项目中

（maven会自动将被依赖的jar包导入进来）

![](images/1.png)



（其实是一组jar包的引用，并没有把jar包本身复制到工程中，所以并不是目录）

 

 

![](images/2.png)



（开发过程中，所有的路径或配置文件中配置的类路径等都是以编译结果的目录结构为标准的）

 

 

## 构建过程中的各个环节

a.      清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备

b.      编译：将java源程序编译成class字节码文件

c.       测试：自动测试，自动调用Junit程序

d.      报告：测试程序执行的结果

e.      打包：动态web工程打war包，java工程打jar包

f.       安装：maven特定的概念—》将打包得到的文件复制到“仓库”中指定位置

g.      部署：将动态web工程生成的war包复制到servlet容器的指定目录下，使其可以运行;jar 包可直接运行java -jar运行

 

 

![](images/3.png)



约定>配置>编码

 

 

#### 常用maven命令：

a.      注意：执行与构建过程相关的maven命令，必须进入pom.xml所在的目录

b.      常用命令：

mvn clean ：清理

mvn compile：编译主程序

mvn test-compile：编译测试程序

mvn test：执行测试

mvn package：打包

mvn install：安装

- mvn install:install-file -Dfile=D:\dev\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.1 -Dpackaging=jar

mvn deploy：部署

 -DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。 

  -Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。 

mvn clean install -DskipTests=true

 

POM对于maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置

 

#### 坐标：

使用下面三个向量在仓库中唯一定位一个maven工程

a.      groupid：公司或组织域名倒序+项目名

b.      artifactid：模块名

c.       version：版本

 

#### 仓库：

a.      本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有maven服务

b.      远程仓库

I . 私服：搭建在局域网环境中，为局域网范围内的所有maven工程服务（Nexus ）

i.                    中央仓库：架设在Internet上，为全世界所有maven工程服务

ii.                  中央仓库镜像：为了分担中央仓库的流量，提升用户访问速度

 

仓库中保存的内容：maven 工程

a.      maven自身所需要的插件

b.      第三方框架或工具的jar包

c.       我们自己开发的maven工程

 

#### 依赖：

a.      maven解析依赖信息时会导本地仓库中查找被依赖的jar包

对于我们自己开发的maven工程，使用install命令安装后就可以进入仓库（mvn install）

 

b.      依赖的范围

i．               compile

ii．             test

iii．           provided

对主程序有效

对测试程序有效

是否参与打包：不参与打包（就等于不参与部署）

![](images/4.png)



c.       依赖的传递性

可以传递的依赖不必在每个模块工程中都重复声明，在最下面的工程中依赖一次即可

注意：非compile范围的依赖不能传递

d.       

 

 

 

#### 生命周期：

a.      各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行

b.      maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的

 

 

![](images/5.png)

![](images/6.png)

![](images/7.png)

 

 

## 版本管理

总版本号.分支版本号.小版本号-里程碑版本

1) 总版本号的变动一般表示框架的变动

2) 分支版本号：一般表示增加了一些功能

3）小版本号：在分支版本上面进行bug的修复

4）里程碑版本：SNAPSHOT（开发版本、快照版本）--》aipha（内部测试版本）--》beta--》release--》GA（稳定版本、发布版本）

## 依赖范围

1. test范围指的是测试范围有效，在编译和打包时都不会使用这个依赖

2. compile范围指的是编译范围有效，在编译和打包时都会将依赖存储进去

3. provided，在依赖和测试的过程有效，最后生成war包时不会加入，诸如：servlet-api，因为servlet-api,tomcat等web服务器已经存在了，如果再打包会冲突

4. runtime在运行的时候依赖，在编译时不依赖

   **默认依赖范围是compile**

## nexus私服（私有仓库）

局域网内部的仓库

![maven_repos](images/maven_repos.png)







[linux下安装nexus教程](https://www.jianshu.com/p/5fc8fb14d25c)

localhost:8081/nexus 		admin/admin123

**type:**

hosted的仓库。内部项目的发布仓库

(releases：内部的模块中release模块的发布仓库)

（snapshots）:发布内部的SNAPSHOT模块的仓库

（3rd party）：第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去的

proxy的仓库。从远程中央仓库中寻找数据的仓库

group仓库。组仓库用来烦恼歌吧开发人员进行设置的仓库 

### 私有仓库的设置

1. 更新私有仓库的索引

   ![](images/nexus.png)

   

   或者直接下载索引，将其拷贝到中央仓库的索引存储目录中

   ![](images/central.png)

2. 设置镜像

    ![](images/mirror.png)

   ![](images/config.png)

   

3.  在setting.xml配置仓库， 此时本机中的所有maven项目都会去私有仓库中查询依赖（如2图中的Profiles配置）



### 项目的发布

发布版本的配置应该在项目中，依赖包的配置放在maven的setting.xml中

1. 设定release工厂和snapshots工厂

   ![](images/deploy.png)

   

2. 设置访问权限

   ![](images/server.png)

   

3. mvn clean deploy

### 创建项目工厂和设置权限

1. 创建两个工厂：release和snapshots

2. 配置权限

   ![](images/qx.png)

   ![](images/pz.png)

   

3. 创建角色

   ![](images/r.png)

   

4. 创建用户

   ![](images/u.png)

   

5. 创建发布的工厂

   修改url并mvn clean deploy

## Linux 下安装maven 

![](images/QQ截图20181115161141.png)

```java
vi /etc/profile
export MAVEN_HOME=/usr/common/apache-maven-3.5.0
export PATH=$MAVEN_HOME/bin:$PATH
:wq
 source /etc/profile
 mvn -v
```



# redis

及时响应（耗内存）

减少服务调用



实现数据同步：定时器

springboot quartz starter 

quartz scheduler

```java
public void main(String[] args){
  
}
```

### redis分布式锁

http://www.importnew.com/27477.html?utm_source=tuicool&utm_medium=referral

分布式锁一般有三种实现方式：

1. 数据库乐观锁

   加索引、

   （每一个请求，spring mvc都会开辟一个线程）

   java锁是不能跨进程的，所以会出现数据库幻读，脏数据、

2. 基于redis的分布式锁

   

3. 基于Zookeeper的分布式锁

#### 可靠性

首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

1. 互斥性。在任意时刻，只有一个客户端能持有锁
2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁
3. 具有容错性。只要大部分的redis节点正常运行，客户端就可以加锁和解锁。
4. 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人家的锁给解了。

#### 加锁

```java
private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";//nxxx NX|XX, NX -- Only set the key if it does not already exist. XX -- Only set the key if it already exist
    private static final String SET_WITH_EXPIRE_TIME = "PX";// EX = seconds; PX = milliseconds
    private static final Long RELEASE_SUCCESS = 1L;
 
    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(JedisCluster jedisCluster, String lockKey, String requestId, int expireTime) {
        String result = jedisCluster.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
        System.out.println("加锁requestId:"+result);
        if (LOCK_SUCCESS.equals(result)) {
        	System.out.println("放行"+requestId);
            return true;
        }
        System.out.println("拒绝"+requestId);
        return false;
    }
```



#### 解锁

```java

    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public static boolean releaseDistributedLock(JedisCluster jedisCluster, String lockKey, String requestId) {
 
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        Object result = jedisCluster.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
        System.out.println("释放分布式锁requestId:"+result);
        if (RELEASE_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
```



##### 例子

仍然存在的问题：

expireTime时间的设置会存在问题：过期时间已到，接口未跑完，也会出现同时操作的情况

```java
@Override
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = Exception.class)
	public String openGroup(OpenGroupReqpData pdata) throws Exception {
		verifyParam(pdata);// 判空校验
		GroupActivity existGroupActivity = isExistGroupActivity(pdata.getActivityId());// 判断此活动是否有效
		if (!existGroupActivity.getCommunityId().equals(pdata.getCommunityId())) {// 小区和活动是否对应
			throw smartExceptionFactory.getInstance(ActivityErrorMsg.CANNOT_CROSS_COMMUNITY_ERROR);
		}
		UserResident userResident = isExistSmartUserId(pdata.getSmartUserId());// 判断用户是否存在
		GroupRecordInfo record = null;
		// 加锁防刷,防止开团数量太多
		String activityIdKey = GroupConstant.GROUPPREFIX + existGroupActivity.getActivityId();// 锁,唯一标识
		String smartUserIdKey ="";
		int expireTime = 20000;// 过期时间（根据接口情况设定）
		String requestId = UUID.randomUUID().toString();// requestId
		try {
			boolean activityIdLock = RedisTool.tryGetDistributedLock(jedisCluster, activityIdKey, requestId,
					expireTime);
			if (activityIdLock) {
				List<GroupDetailInfo> groupList = groupDetailInfoMapper.findByMemberTypeAndActivityId(1,
						existGroupActivity.getActivityId());
				// 寻宝团已超额，请期待下次活动
				if (!CollectionUtils.isEmpty(groupList)
						&& groupList.size() >= existGroupActivity.getActivityNum().intValue()) {
					throw smartExceptionFactory.getInstance(ActivityErrorMsg.OVER_ACTIVITY_MAX);
				}
				// 根据活动id、成员id、成员类型查询记录
				// 防刷，防止同一个人重复提交
				// 加锁操作（防止同一个人重复提交）
				smartUserIdKey = GroupConstant.GROUPPREFIX + existGroupActivity.getActivityId() + "_"
						+ pdata.getSmartUserId();// 锁,唯一标识
				boolean smartUserIdLock = RedisTool.tryGetDistributedLock(jedisCluster, smartUserIdKey, requestId,
						expireTime);
				if (smartUserIdLock) {
					List<GroupDetailInfo> groupDetailInfoList = groupDetailInfoMapper
							.findByMemberIdAndMemberTypeAndActivityId(pdata.getSmartUserId(), 1,
									existGroupActivity.getActivityId());
					// 判断是否超过最大开团数
					if (!CollectionUtils.isEmpty(groupDetailInfoList)
							&& groupDetailInfoList.size() >= existGroupActivity.getOpenGroupMax()) {
						throw smartExceptionFactory.getInstance(ActivityErrorMsg.OVER_OPEN_GROUP_MAX);
					}
					// 符合所有条件可开团
					Short groupStatus = 1;// （1-组团中 2-成团 0-拼团失败）/(1-有效 0-无效)
					Short currentNum = 0;// 当前人数
					Short amountNum = existGroupActivity.getGroupNum().shortValue();// 成团总人数
					// taskFinished (是否全部完成任务：1-完成 0-未完成)
					record = new GroupRecordInfo(IdFactory.creeateId(new Date()),
							GroupName.getName(groupDetailInfoList.size() + 1), pdata.getActivityId(),
							pdata.getCommunityId(), groupStatus, currentNum, amountNum, existGroupActivity.getEndTime(),
							userResident.getNickName(), 0);
					int insertSelective = groupRecordInfoMapper.insertSelective(record);
					if (insertSelective < 0) {
						LOGGER.error("开团接口系统异常，保存拼团信息表时出错，出错参数：{}", record);
						throw new RuntimeException();
					}
					Short memberType = 1;// 成员类型（1-团长 2-团员）
					Short iscompleted = 0;// 是否完成任务（0-未完成 1-已完成）
					Short isExist = 1;// 是否在团（0-否 1- 是）
					GroupDetailInfo detailRecord = new GroupDetailInfo(IdFactory.creeateId(new Date()),
							record.getGroupId(), pdata.getSmartUserId(), memberType, iscompleted, isExist,
							pdata.getActivityId());
					int insertSelective2 = groupDetailInfoMapper.insertSelective(detailRecord);
					if (insertSelective2 < 0) {
						LOGGER.error("开团接口系统异常，保存拼团详情表时出错，出错参数：{}", detailRecord);
						throw new RuntimeException();
					}
				} else {
					// 操作过于频繁，请重新操作
					throw smartExceptionFactory.getInstance(ActivityErrorMsg.FREQUENT_OPERA_ERROR);
				}
			} else {
				// 当前在线活动人数较多，请重新操作
				throw smartExceptionFactory.getInstance(ActivityErrorMsg.CURRENT_MORE_MEMBER_ERROR);
			}
		} finally {
			// 解锁操作
			RedisTool.releaseDistributedLock(jedisCluster, activityIdKey, requestId);
			RedisTool.releaseDistributedLock(jedisCluster, smartUserIdKey, requestId);
		}
		return record.getGroupId();
	}

```



###  队列的常用命令:

- rpush(key, value)：在名称为key的list尾添加一个值为value的元素
- lpush(key, value)：在名称为key的list头添加一个值为value的 元素
- llen(key)：返回名称为key的list的长度
- lrange(key, start, end)：返回名称为key的list中start至end之间的元素
- ltrim(key, start, end)：截取名称为key的list
- lindex(key, index)：返回名称为key的list中index位置的元素
- lset(key, index, value)：给名称为key的list中index位置的元素赋值
- lrem(key, count, value)：删除count个key的list中值为value的元素
- lpop(key)：返回并删除名称为key的list中的首元素
- rpop(key)：返回并删除名称为key的list中的尾元素
- blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
- brpop(key1, key2,… key N, timeout)：rpop的block版本。
- rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部

#### 例子

```java
@Override
	public void collectFormId(GroupGollectFormIdReqpData pdata) throws Exception{
		verifyGroupId(pdata.getGroupId());
		vefifySmartUserId(pdata.getSmartUserId());
		if(StringUtils.isEmpty(pdata.getFormId())){
			throw smartExceptionFactory.getInstance(ActivityErrorMsg.FORMID_CANNOT_NULL);
		}
		String key =GroupConstant.GROUP_QUEUE_KEY+pdata.getSmartUserId();
		String openId ="";
		int seconds = 604800;//有效期7天
		Long llen = jedisCluster.llen(key);//返回名称为key的list的长度
		int retain = RETAIN;
		if(llen == retain || llen>retain){
			jedisCluster.lpop(key);//删除最上面的一个值
		}
		UserResident userResident = userResidentMapper.selectByPrimaryKey(pdata.getSmartUserId());
		if(userResident !=null && !"".equals(userResident.getWeiChatOpenId())){
			openId = ","+userResident.getWeiChatOpenId();
			String now = Instant.now().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()+",";
			jedisCluster.rpush(key,now+pdata.getFormId()+openId);//在名称为key的list尾添加一个值为value的 元素
			jedisCluster.expire(key, seconds);
			LOGGER.info("收集formId：key={},value={}",key,now+pdata.getFormId()+openId);
		}
	}
```



### PLSQL  快捷键

Ctrl +tab 切换sql窗口

ctrl +e 历史输入

select id, createtime, isdelete, updatetime, user_room_rp_id from sh_gift_registry

```sql
1 选中表,拖放到sqlwindow中

2 选择insert/select 

3 在自动打印出的insert语句中复制该表的所有字段然后粘贴到你需要的位置
```



## mysql







# 前后端系统设计图

（前后端分离就是：前端的业务不会耦合后端，前端和后端可以完全分开来部署）

## 前后端分离总体架构：

前端：springboot+th+bookstrap

后端：springcloud：eureka+ribbon+feign+zuul

```mermaid
graph TD
A[用户]-->B(nginx)
B-->B1(前端)
B-->B2(前端)
B-->B3(前端)
B1-->C
B2-->C
B3-->C
C(nginx/zuul)
C-->C1[user后端]
C-->C2[order后端]
C-->C3[报表后端]
```

（eureka是负载算出zuul当次请求到底是应该访问哪个微服务的哪个节点的，实际上是zuul问eureka要访问地址，然后zuul根据eureka给的访问地址直接访问微服务的）

(所有的user微服务，spring.application.name 都是相同的,那么eureka会维护了一个map,key就是microservice-provider-user,value就是：List<String>=[192.168.100:8080,192.168.101:9080,192.168.102:9900]
然后zuul就会拿到microservice-provider-user,然后有请求过来了，zuul就会告诉eureka，你给我一个microservice-provider-user的value；然后eureka可能就会算出192.168.101:9080这个值给zuul
然后zuul就知道具体是去访问哪个微服务了)

```mermaid
graph TD
C1[user后端] --> |注册到|D[Eureka]
C2[order后端]--> |注册到|D[Eureka]
C3[报表后端]--> |注册到|D[Eureka]
C1-->|feign|C2
C2-->|feign|C1
```

### 前端

bootstrap 的metronic模板、 thymeleaf 、 springboot、WebJars（springboot提供给前端的各种jar包）

thymeleaf：引包、配置、使用

```xml
<!-- 模板引擎 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>
```

```yaml
server:
  port: 8088
  
#thymeleaf-springboot配置
spring:
  thymeleaf: #页面模板引擎
    cache: true #是否缓存，有缓存时会导致页面没法及时看到更新后的效果
    content-type: text/html; charset=utf-8
    enabled: true #是否启用
    encoding: UTF-8
    mode: HTML5
    prefix: classpath:/templates/
    suffix: .html
   #static   （静态资源） 
  resources:
    add-mappings: true
    cache-period: 3600
    static-locations:
    - classpath:/static/
    chain:
      cache: true
      enabled: true
      gzipped: true
      html-application-cache: true
```

```xml
<!-- https://www.webjars.org/ -->
<!-- jquery -->
<dependency>
  <groupId>org.webjars</groupId>
  <artifactId>jquery</artifactId>
  <version>1.10.2</version>
</dependency>
<!-- bootstrap -->
<dependency>
  <groupId>org.webjars</groupId>
  <artifactId>bootstrap</artifactId>
  <version>3.1.1</version>
</dependency>
<!-- font-awesome -->
<dependency>
  <groupId>org.webjars</groupId>
  <artifactId>font-awesome</artifactId>
  <version>4.0.3</version>
</dependency>
```

```html
<link th:href="@{/webjars/font-awesome/4.0.3/css/font-awesome.min.css}"  rel="stylesheet" type="text/css"/>
<link th:href="@{/webjars/bootstrap/3.1.1/css/bootstrap.min.css}" rel="stylesheet" type="text/css"/>
```



### 后端

spring+spring MVC+sping jpa

springcloud：eureka+ribbon+feign+zuul

hystrix（超时机制，fallback）、分布式应用日志跟踪（springcloud sleuth）

数据库：mysql+druid

缓存：redis

消息队列：ribbitmq

后台管理平台服务的权限框架用到shiro/spring cecurity

（自动部署：docker Jenkins）

登录授权鉴权 ：jwt token+shiro

步骤：

工作空间是：probject_workspace

1. 先搭起springcloud框架

   springboot 1.5.16 、swagger2 2.5.5、springcloud Edgware.SR3

   lombok、

   注意：以组件的形式搭框架

   **配置yml多文档快的文件配置** 

   ```xml
   spring: 
     application:
       name: microservice-provider-web
     profiles:
       active:
       - prod
       
   eureka: 
     client:
       service-url:
         defaultZone: http://localhost:8761/eureka/
     instance:
       prefer-ip-address: true
       instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}  

   ---
   server:
     port: 7900

   spring:
     profiles: dev
   api: 
     docs: enable

   ---
   server:
     port: 7901

   spring:
     profiles: test
   api: 
     docs: enable
     
   ---
   server:
     port: 7902

   spring:
     profiles: prod  

   api: 
     docs: disable
     
   ```

   测试方法：--spring.profiles.active=dev

   ![](images/QQ截图20181011114014.png)

   

   ```xml
   <!-- 引入springcloud的依赖 -->
   <dependencyManagement>
     <dependencies>
       <dependency>
         <groupId>org.springframework.cloud</groupId>
         <artifactId>spring-cloud-dependencies</artifactId>
         <version>Edgware.SR3</version>
         <type>pom</type>
         <scope>import</scope>
       </dependency>
     </dependencies>
   </dependencyManagement>
   ```

   ```xml
   <!-- Eureka服务中心 -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
   </dependency>
   ```

   ```java
   @EnableEurekaServer
   ```

   ```xml
   <!--Eureka客户端 -->
   <!--引包、配置、注解 -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

   

   ![](images/QQ图片20181010181727.png)

   swagger2：引依赖、配置、加注解

   ```xml
   <!-- swagger2两个依赖包 -->
   <dependency>
     <groupId>io.springfox</groupId>
     <artifactId>springfox-swagger2</artifactId>
     <version>2.5.0</version>
   </dependency>

   <dependency>
     <groupId>io.springfox</groupId>
     <artifactId>springfox-swagger-ui</artifactId>
     <version>2.5.0</version>
   </dependency>
   ```

   ```java
   @Configuration
   @ConditionalOnProperty(prefix = "api", name = "docs", havingValue = "enable", matchIfMissing = false)
   @Import({ Swagger2DocumentationConfiguration.class })
   public class Swagger2 {

   	/*
   	 * @Value("${api.docs}") private boolean enableSwagger;
   	 */

   	@Bean
   	public Docket createRestApi() {
   		/*
   		 * return new
   		 * Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).enable(enableSwagger).
   		 * select()
   		 */

   		return new Docket(DocumentationType.SWAGGER_2)
   				.globalOperationParameters(Lists.newArrayList(new ParameterBuilder().name("")
   						.modelRef(new ModelRef("string")).parameterType("header").build()))
   				.select()

   				.apis(RequestHandlerSelectors.basePackage("com.example.demo"))// controller包的路径
   				.paths(PathSelectors.any()).build();
   	}

   	private ApiInfo apiInfo() {
   		return new ApiInfoBuilder().title("springboot利用swagger2构建api文档")
   				.description("简单优雅的restful风格的API文档，http://www.baidu.com").termsOfServiceUrl("http://www.baidu.com")
   				.version("1.0").build();
   	}

   }
   ```

   ```xml
   api: 
     docs: enable
   //@EnableSwagger2(swagger2可通过配置文件配置开启或关闭)
   ```

   - 封装结果返回格式

     - Dto
     - DtoUtils
     - CodeEnum


   ​

   mysql 的配置：引包mysql、druid、配置、

   引入jpa：引包、配置

   ```yaml
   spring: 
     application:
       name: microservice-provider-web
     profiles:
       active:
       - dev
     jpa: #jpa
       hibernate: 
         ddl-auto: none
       database: MYSQL
       dialect: org.hibernate.dialect.MySQL5Dialect  
     datasource: #druid配置
       username: 
       password: root
       url:  jdbc:mysql://192.168.0.173:3306/probjectcloud?useUnicode=true&characterEncoding=utf8&useSSL=true
       driver-class-name: com.mysql.jdbc.Driver
       # 数据源类型：Druid
       type: com.alibaba.druid.pool.DruidDataSource
       druid:
         initial-size: 5
         min-idle: 5
         max-active: 20
         max-wait: 60000 # 获取连接等待超时的时间
         time-between-eviction-runs-millis: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
         min-evictable-idle-time-millis: 300000 # 配置一个连接在池中最小生存的时间，单位是毫秒
         validation-query: select 'x'
         filters: stat,wall # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
         test-while-idle: true
         test-on-borrow: false
         test-on-return: false
         pool-prepared-statements: true
         max-pool-prepared-statement-per-connection-size: 20 # 打开PSCache，并且指定每个连接上PSCache的大小
   #      connect-properties: 
   #       druid: stat.mergeSql=true;druid.stat.sflowSqlMillis:500  # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
         use-global-data-source-stat: true # 合并多个DruidDataSource的监控数据      
   ```

2. 菜单

   简单的菜单返回接口：（rest api json格式 ）

   表设计：

   接口编写：

3. 引入服务网关zuul

   引包、加配置、（使用）加注解、

   ```xml
   <!-- zuul -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
   </dependency>
   <!--Eureka客户端 -->
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

   

   ```yaml
   server:
     port: 8040
     
   spring:
     application:
       name: microservice-gateway-zuul

   #eureka client    
   eureka: 
     client:
       service-url:
         defaultZone: http://localhost:8761/eureka/
     instance:
       prefer-ip-address: true
       instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}    
   ```

   ```java
   @EnableZuulProxy
   ```

   

4. 服务间调用用feign

   引包：spring-cloud-starter-openfeign

   ```java
   @EnableFeignClients
   ```

   ```java
   package com.zhangbin.cloud.feign;

   import org.springframework.cloud.netflix.feign.FeignClient;
   import org.springframework.http.MediaType;
   import org.springframework.web.bind.annotation.GetMapping;

   @FeignClient("microservice-provider-web")
   public interface SystemFeignClient {
   	
   	@GetMapping(value = "/getAllMenu",produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
   	public String getAllMenu();
   }

   ```


   ```java
   重写了setMsg方法导致类型转换失败：
   ```

   ​

   ![](images/QQ截图20181114104036.png)

5. druid监控

   - 地址：http://localhost:7900/druid/index.html

6. 用户鉴权到真实功能控制

   - 鉴权方式

     - 单体应用框架
       - http协议是一种无状态协议，即每次服务端收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；session的主要目的就是为了弥补http的无状态特性。简单的说，就是服务器可利用session存储客户端在同一个会话期间的一些操作记录。
     - 分布式应用框架
       - session 绑定：即将同一用户的所有请求都分发到同一台服务器上
         - 优点：简单，不需要对session做任何处理
         - 缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，它的session信息都将失效
       - session复制：任何一个服务器上的session发生改变（增删改），该节点会把这个session的所有内容序列化，然后广播给所有其他节点，不管其他服务器需不需要session，以此来保证session同步
         - 优点：可容错，各个服务器间session能够实时响应
         - 缺点：会对网络负荷造成一定压力，如果session量大的话，可能会造成网络堵塞，拖慢服务器性能
       - session共享：将原本存储在内存中的session，放入一个公共的缓存当中（如redis、memcached），服务器根据请求去缓存中读取session
         - 可容错，服务器不需要存储session减少内存占用
     - 微服务架构中的身份认证服务
       - 单点登录（SSO）
         - 采用单点登录方案，意味着每个面向用户的服务都必须与认证服务交互，这会产生大量非常琐碎的网络流量，同时这个防范实现起来也相当的复杂，同时重构相当麻烦，因为需要兼容所有系统。在其他方面，选择sso方案安全性很好，用户登录状态是不透明的，可防止攻击者从状态中推断任何有用的信息
       - 分布式session
         - 分布式会话方案原理主要是将关于用户认证的信息存储在共享存储中，且通常由用户会话作为key来实现的简单分布式哈希映射。当用户访问微服务时，用户数据可从共享存储中获取。在某些场景下，这种方案很不错，用户登录状态是不透明的。同时也是一个高可用且可扩展的解决方案。
           - 缺点：在于共享存储需要一定保护机制，因此需要通过安全链接来访问，这时解决方案的实现就通常具有相当高的复杂性了
       - 客户端Token
         - 令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可在所有微服务中建立用户身份。令牌会附加到每个请求上，为微服务提供用户身份验证，这种解决方案的安全性相对较好，但身份验证注销是一个大问题，缓解这种情况的方法可使用短期令牌和频繁检查认证服务等。对于客户端令牌的编码方案，可使用JSON Web Tokens（JWT），它够简单且库支持程度也较好
       - 客户端Token与API网关结合
         - 这个方案意味着所有请求都通过网关，从而有效地隐藏了微服务。在请求时，网关将原始用户令牌转换为内部会话ID令牌。在这种情况下，注销就不是问题，因为网关可在注销时撤销用户的令牌

   - 权限处理

     - 用户的权限控制
     - 系统服务的权限控制

   - 统一网关服务

     - 实现签名验证、IP过滤、统一转发等功能，同时基于Hystrix实现对服务的监控功能

   - JWT

     - ```xml
       <!-- JWT -->
       		<dependency>
       			<groupId>com.auth0</groupId>
       			<artifactId>java-jwt</artifactId>
       			<version>3.3.0</version>
       		</dependency>
       ```

     - ```java
       /**登录Token的生成和解析
        * @author admin
        *
        */
       public class JwtToken {
       	
       	/** token 秘钥，请勿泄露，请勿随便修改*/
       	public static final String SECRET = "52DTHVwS8YYP7ay0";
       	
       	/** token 过期时间：10天*/
       	public static final int calendarField = Calendar.SECOND;
       	public static final int calendarInterval = 30;
       	
       	/**
       	 * JWT生成Token
       	 * @param userId
       	 * @return
       	 * @throws Exception
       	 */
       	public static String createToken(Long userId) throws Exception {
       		Date iatDate = new Date();
       		Calendar nowTime  = Calendar.getInstance();
       		nowTime.add(calendarField, calendarInterval);
       		Date expiresDate = nowTime.getTime();
       		/**
       		 * JWT三部分：
       		 * 头部 header
       		 * 载荷 payload
       		 * 签名signature
       		 */
       		//header Map
       		Map<String, Object> map = new HashMap<>();
       		map.put("alg", "HS256");
       		map.put("typ", "JWT");
       		
       		//build token
       		String token = JWT.create().withHeader(map)
       			.withClaim("iss", "Service")//payload
       			.withClaim("aud", "APP")
       			.withClaim("userId", null == userId? null:userId.toString())
       			.withIssuedAt(iatDate)//sign time
       			.withExpiresAt(expiresDate)//expire time
       			.sign(Algorithm.HMAC256(SECRET));//signature
       			
       		return token;
       	}
       	
       	/**
       	 * 解密Token
       	 * @param token
       	 * @return
       	 */
       	public static Map<String, Claim> verifyToken(String token){
       		DecodedJWT jwt = null;
       		try {
       			JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET)).build();
       			jwt = verifier.verify(token);
       		} catch (Exception e) {
       			e.printStackTrace();
       			throw new RuntimeException("登录凭证已过期，请重新登录");
       		}
       		return jwt.getClaims();
       	}
       	
       	/**
       	 * 根据Token获取userId
       	 * @param token
       	 * @return
       	 */
       	public static Long getAppUID(String token) {
       		Map<String, Claim> claims = verifyToken(token);
       		Claim userIdClaim = claims.get("userId");
       		if(null == userIdClaim || StringUtils.isEmpty(userIdClaim.asString())) {
       			//token校验失败，抛出Token验证非法异常
       			System.out.println("token校验失败");
       		}
       		return Long.valueOf(userIdClaim.asString());
       	}
       	
       	public static void main(String[] args) throws Exception {
       		//获取token
       		/*Long userId = 1111L;
       		String createToken = createToken(userId);
       		System.out.println("获取token:"+createToken);*/
       		//解析token
       		String token1 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJBUFAiLCJpc3MiOiJTZXJ2aWNlIiwiZXhwIjoxNTQ3MzY5MDM3LCJ1c2VySWQiOiIxMTEyIiwiaWF0IjoxNTQ2NTA1MDM3fQ.NBxyu0j7HiaBrm10nQLKz5cVFGpYo2mJORlFHIZLoKM";
       		Map<String, Claim> verifyToken1 = verifyToken(token1);
       		System.out.println("解析token:"+verifyToken1);
       		String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJBUFAiLCJpc3MiOiJTZXJ2aWNlIiwiZXhwIjoxNTQ2NTA1NzEyLCJ1c2VySWQiOiIxMTExIiwiaWF0IjoxNTQ2NTA1NjgyfQ.NVSo4OkUm2K8q8XuoljLVxuuOzymTMDiurzGfVuoL9o";
       		Map<String, Claim> verifyToken = verifyToken(token);
       		System.out.println("解析token:"+verifyToken);
       		//根据token获取userId
       		Long appUID = getAppUID(token);
       		System.out.println("根据token获取userId:"+appUID);
       		/**
       		 * 	获取token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJBUFAiLCJpc3MiOiJTZXJ2aWNlIiwiZXhwIjoxNTQ3MzY5MDAxLCJ1c2VySWQiOiIxMTExIiwiaWF0IjoxNTQ2NTA1MDAxfQ.DWye2Yhdbi5ufeK6Z9ukxcghWiQF6k2uJA9YlcGDLo8
       			解析token:{aud=com.auth0.jwt.impl.JsonNodeClaim@70ed52de, iss=com.auth0.jwt.impl.JsonNodeClaim@496bc455, exp=com.auth0.jwt.impl.JsonNodeClaim@59402b8f, userId=com.auth0.jwt.impl.JsonNodeClaim@7188af83, iat=com.auth0.jwt.impl.JsonNodeClaim@6be968ce}
       			根据token获取userId:1111
       			
       			获取token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJBUFAiLCJpc3MiOiJTZXJ2aWNlIiwiZXhwIjoxNTQ3MzY5MDM3LCJ1c2VySWQiOiIxMTEyIiwiaWF0IjoxNTQ2NTA1MDM3fQ.NBxyu0j7HiaBrm10nQLKz5cVFGpYo2mJORlFHIZLoKM
       			解析token:{aud=com.auth0.jwt.impl.JsonNodeClaim@5ddeb7cb, iss=com.auth0.jwt.impl.JsonNodeClaim@70ed52de, exp=com.auth0.jwt.impl.JsonNodeClaim@496bc455, userId=com.auth0.jwt.impl.JsonNodeClaim@59402b8f, iat=com.auth0.jwt.impl.JsonNodeClaim@7188af83}
       			根据token获取userId:1112
       		 */
       	}
       }

       ```

     - 用户表

     - 

7. 网关架构

   - 登录模块
     - 删除用户时，还可用原来token访问，待处理
     - 用户权限角色每一次登录都访问数据库问题待处理
   - 公共模块
     - 文件上传接口待完善


   - 用户管理
   - 角色关联
   - 菜单、动作管理
   - 操作日志
   - 客户端注册
   - 服务管理和授权
   - 网关黑白名单和IP限制
   - 服务状态监控与提醒
   - 服务追踪

8. 










### 搭建项目时遇到的坑

1. jar包损坏

   查看jar包是否有没有损坏

   如果知道具体jar包，删掉重新下载

   如果不知道把仓库的所有包删掉重新下载（或换个仓库）

2. 




> 问题：
>
> - @ApiParam(value = "参数",required = true)无生效？
> - swagger 类型无法识别？

# java零碎知识点 

## 序列化和反序列化

- 序列化：把对象转换为字节序列的过程称为对象的序列化
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化

### 什么情况下需要序列化 

- 当想把内存中的对象状态保存到一个文件中或者数据库中时候
- 当想用套接字在网络上传送对象的时候
- 当想通过RMI传输对象的时候

### 如何实现序列化 

**实现Serializable接口即可**

**实现Serializable接口时，一定要给这个serialVersionUID赋值**

（如果没有，在后来的扩展的时，可能就会出现不认识旧数据的bug：）

详细介绍：https://blog.csdn.net/qq_27093465/article/details/78544505 



serialVersionUID的取值是java运行时环境根据类的内部细节自动生成的。如果对类的源代码做了修改，再重新编译，新生成的类文件的serialVersionUID取值有可能也会发生变化。



**赋值1L就ok啦**，这样就可确保代码一致时反序列化成功。

（不同的serialVersionUID的值，反而会影响到反序列化，值不同，就会抛InvalidClassException 异常）

- 

# swagger 

- 实体
  - 实体注释：@ApiModel
  - 属性注释：@ApiModelProperty(value ="ID")
- 接口
  - @API：修饰整个类，描述controller的作用

  - @APIOperation]()：描述一个类的一个方法，或者说一个接

  - @APIParam：单个参数描述

    - ```
      @ApiParam(name = "title", value = "公告标题", required = true) @RequestParam("title") String title
      ```

  - @ApiModel：用对象来接收参数

  - @APIProperty：用对象接收参数时，描述对象的一个字段

  - @APIResponse：Http响应其中1个描述

  - @APIResponses：http响应整体描述

  - @APIlgnore：使用该注解忽略这个api

  - @APIError：发生错误返回的信息

  - @APIImplicitParam：一个请求参数

  - @APIImlplicitParams：多个请求参数

    - @APIImlplicitParams(@APIImplicitParam(),)


# 测试技术 

## JMeter 

## MockMvc 

## Selenium 

- 浏览器自动化测试框架

## LoadRunner

## apache bench 测试网站性能

https://www.cnblogs.com/Ryana/p/6279232.html

# hibernate validator 

- spring-boot-starter-web包里面有hibernate-validator包，不需要引用hibernate validator依赖
  - https://www.cnblogs.com/mr-yang-localhost/p/7812038.html

- 级联校验
  - https://blog.csdn.net/liuchuanhong1/article/details/52042294


- ```java
  package wo.smart.home.com.validator;

  import java.util.HashMap;
  import java.util.Iterator;
  import java.util.Map;
  import java.util.Set;

  import javax.validation.ConstraintViolation;
  import javax.validation.Validation;

  import org.springframework.util.StringUtils;

  public class ValidatorUtil {
  	
  	/**
  	 * 校验实体参数，并返回校验不通过的字段和描述
  	 * @param t
  	 * @return
  	 * @throws Exception
  	 */
  	public static Map<String, String> validatorParams(Object t) throws Exception {
  		Set<ConstraintViolation<Object>> validResult = Validation.buildDefaultValidatorFactory().getValidator()
  				.validate(t);
  		Map<String, String> map = new HashMap<>();
  		if (null != validResult && validResult.size() > 0) {
  			for (Iterator<ConstraintViolation<Object>> iterator = validResult.iterator(); iterator.hasNext();) {
  				ConstraintViolation<Object> constraintViolation = (ConstraintViolation<Object>) iterator.next();
  				if (!StringUtils.isEmpty(constraintViolation.getMessage())) {
  					map.put(constraintViolation.getPropertyPath().toString(), constraintViolation.getMessage());
  				}
  			}
  		}
  		return map;
  	}
  }

  ```

- ```java
  /**
  	 * 创建通知
  	 * @param smartReqp
  	 * @return
  	 * @throws Exception 
  	 */
  	@PostMapping(value=ContextPath.MANGESYSTEM+PathConstant.PROPERTY_MAIN+"/createNotice")
  	@ResponseBody
  	@ValidateParam
  	public SmartResult<SmartListVo> createNotice(@RequestBody SmartReqp<OwnerNotice> smartReqp,ManageUserRedisInfo redisInfo) throws Exception{
  		judgeManageUser(redisInfo);
  		Map<String, String> validatorParams = ValidatorUtil.validatorParams(smartReqp.getPdata());
  		if(!validatorParams.isEmpty()){
  			return SmartListVo.assemble(10001, "表单校验异常",validatorParams);
  		}
  		ownerNoticeBussiness.createNotice(smartReqp.getPdata(),redisInfo);
  		return SmartResult.build(ResultCode.SUCCESS, ResultMsg.SUCCESS,null);
  	}
  ```



# powerdesigner 

- minimum ：最小值
- maximum：最大值
- default ：默认值
- comment：列注释
- mandatory：非空设置
- 

# 20190617

## 项目实战

- 项目管理

  - jir+confluence
- 发布管理

  - docker++k8s灰度发布+jekins+git
- 测试管理

  - 测试工具：白盒？黑盒？

  - jir+confluence
- 开发管理

  - git
- 公共部分：
  - 文件上传、订单模块、支付模块、搜索模块、（用户、商品、评价、交易、营销）

## 补充能量

- 数据结构

## 英国垃圾

## 老项目 



# 进阶

https://juejin.im/post/5d2d2ba96fb9a07f050a9ad6

性能优化：

1、JVM调优

2、Java程序性能优化

3、Tomcat

4、Mysql

5、Spring IOC

6、Spring AOP

7、Spring MVC

8、Spring 5新特性

9、Mybatis

 

分布式架构：

1、架构核心服务层技术

2、架构关键技术设施

3、分布式消息通讯 异步于MQ

4、分布式缓存

5、Redis

6、Memcached

7、MongoDB

8、数据存储

9、高并发分流技术Nginx

10、分布式解决方案

性能调优

![](images/20180510101359383.png)



应用框架源码解读

![](images/20180510101405686.png)



分布式架构

![](images/20180510101413572.png)



微服务专题

![](images/20180510101421815.png)



团队协作开发

![](images/20180510101427900.png)

B2C商城项目实战

![](images/20180510101434131.png)



- 商城实战
  - 上图，项目实战
- 部署实战
  - 周末搞
- 性能调优
  - 如上图
  - 看书，实战

## 实战 

### 商品管理

> - 商品管理
>   - 商品发布、下架、调整
>   - 商品分类
>     - 一级类目：家用电器
>     - 二级类目：电视、空调
>     - 三级类目：电视分类
>     - 具体商品：全面屏、升级版
>   - 热卖商品排行
>   - 商品推荐：商品推荐常规推荐和个性化推荐
>   - 商品搜索
>   - 商品评论：关键词、敏感词汇的筛选、评论等级等
>   - 商品管理：对商品的增删改查以及上下架等其他操作
>   - 价格管理、促销管理、标签管理、商家管理、库存管理、其他（限购数量、会员折扣、积分等等）
>
> https://coffee.pmcaff.com/article/1007664891113600/pmcaff?utm_source=forum&from=related&pmc_param%5Bentry_id%5D=1010386918803520 
>
> http://www.woshipm.com/it/816727.html
>
> | 一级分类 | 二级分类             |      | 属性     | 属性值     |      |
> | -------- | -------------------- | ---- | -------- | ---------- | ---- |
> | 数码     | 手机（最小品类单位） |      | 品牌     | 华为、苹果 |      |
> |          |                      |      | 操作系统 |            |      |
> |          |                      |      | 屏幕尺寸 |            |      |
> |          |                      |      | 网络     |            |      |
> |          |                      |      | 颜色     |            |      |
> |          |                      |      | 保修方式 |            |      |
> |          |                      |      | 套餐     |            |      |
> | 电器     |                      |      |          |            |      |
> | 食品     | 饮料                 |      |          |            |      |
>
> 

#### 商品添加 

> - 分类：选择一个分类，不可多选
>
> - 标题：
> - 品牌
> - 规格：选择规格或规格组，多个规格和规格值选择完成后要进行编辑对应的sku信息，有进货价格，销售价格，虚拟价格，库存，sku编码，保存后生成总库存
> - 参数
> - 标签：（七天包退，14天包换，。。。）
> - 商品图
> - 商品详情：（商品的多张图片，视频介绍，商品的价格区间，商品原价，商品标题，自营标签，商品点赞人数，分享按钮，添加购物车按钮，商品发货地址，快递费，销量，优惠券信息，领券按钮，服务信息，规格选择，参数选择，评价，详情，商品推荐等。底部还有，店铺入口，客服，收藏按钮，加入购物车，立即购买）
> - 物流信息等：

### 商品分类 

> 前台类目和后台类目
>
> （前台分类一定是要挂靠在后台分类之下，商品必须挂靠在最下级分类之下，也就是最小分类，并且只能挂靠一个分类）

### 品牌管理 

> LOGO、中文名、英文名、产地、备注、状态（是否启用，启用之后再创建商品的时候才能拉取到）、操作（创建新品牌、编辑、删除、启用/禁用）

### 规格管理 

> 多规格单选
>
> 规格名称、所属后台分类、规格值（红色、黑色、蓝色）、创建时间、更新时间、备注、操作（修改、删除（规格下有商品时无法删除）、启用/禁用（禁用后分类下找不到此规格））

规格组管理、参数管理？不懂了

http://www.woshipm.com/pd/2122609.html

### 商品推荐 

### 商品搜索

### 商品评论

> - 敏感词处理：（星号）
> - 评价形式：文字评价、图文评价、视频评价、星级评价（一到五星）
> - 评价管理：发布审核、商家回复、评价排序、默认评价、



# 单点登录 

- SSO ：指在多个应用系统中，用户只需要登陆一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一用户的登陆的机制。

  - 完全同域SSO：指的是域名完全相同的多个应用系统中实现单点登录。

  - 同父域SSO：指的是父域名相同的应用系统上实现SSO

    - >  web1.x.com
      >
      > web2.x.com
      >
      > web3.x.com

    - 

  - 跨域SSO：在域名完全不同的应用程序上实现SSO

    - 问题：应用群的安全性问题：木桶效应（a\b\c\d系统，只要有一个系统有安全漏洞，就会通过这个系统攻击其他系统，所以要保证整个应用群安全性高）

- **单点登录核心：核心是cookie，需要注意设置的域、位置和安全性（加密、签名）** 

# 分布式性能管理监控工具 

- pinpoint
- skywalking
- prometheus





# 代码规范 

## 不要在循环条件中计算

```java
while(i<count*2){}
//替换为：
int total = count*2
while(i<total){}
```

## 尽量把变量、方法声明为final static类型

## 缩小变量的作用范围

- 关于变量，能定义在方法内的就定义在方法内，能定义在一个循环体内的就定义在循环体内。。。，其目的是加快GC的回收

## 频繁字符串操作使用StringBuilder或StringBuffer

```java
String str ="";
for(int i=0;i<max;i++){
    str +=i;
}
//替换为：
StringBuilder sb = new StringBuilder(200);
for(int i=0;i<max;i++){
   sb.append(i);
}

```



# API接口设计规范 

## 路由命名规范

| 动作 | 前缀   | 备注         |
| ---- | ------ | ------------ |
| 获取 | get    | get{XXX}     |
| 获取 | get    | get{XXX}List |
| 新增 | add    | add{XXX}     |
| 修改 | update | update{XXX}  |
| 保存 | save   | save{XXX}    |
| 删除 | delete | delete{XXX}  |
| 上传 | upload | upload{XXX}  |
| 发送 | send   | send{XXX}    |

## 请求方式

| 请求方式 | 描述     |
| -------- | -------- |
| GET      | 获取数据 |
| POST     | 新增数据 |
| PUT      | 更新数据 |
| DELETE   | 删除数据 |

## 请求参数

#### Query

url?后面的参数，存放请求接口的参数数据。

#### Header

请求头，存放公共参数、requestId、token、加密字段等。

#### Body

Body 体，存放请求接口的参数数据。

#### 公共参数

**APP 端请求**

| 参数       | 说明         | 备注                |
| ---------- | ------------ | ------------------- |
| network    | 网络         | WIFI、4G            |
| operator   | 运营商       | 中国联通/移动       |
| platform   | 平台         | iOS、Android        |
| system     | 系统         | ios 13.3、android 9 |
| device     | 设备型号     | iPhone XR、小米9    |
| udid       | 设备唯一标示 |                     |
| apiVersion | API 版本号   | v1.1、v1.2          |

**WEB 端请求**

| 参数   | 说明    | 备注   |
| ------ | ------- | ------ |
| appKey | 授权Key | 字符串 |

调用方需向服务方申请 appKey（请求时使用） 和 secretKey（加密时使用）。

## 日志平台设计

日志平台有利于故障定位和日志统计分析。

日志平台的搭建可以使用的是 `ELK` 组件，使用 `Logstash` 进行收集日志文件，使用 `Elasticsearch` 引擎进行搜索分析，最终在 `Kibana` 平台展示出来。

## 幂等性设计

我们无法保证接口的每一次调用都是有返回结果的，要考虑到出现网络异常的情况。

举个例子，订单创建时，我们需要去减库存，这时接口发生了超时，调用方进行了重试，这时是否会多扣一次库存？

解决这类问题有 2 种方案：

一、服务方提供相应的查询接口，调用方在请求超时后进行查询，如果查到了，表示请求处理成功了，没查到就走失败流程。

二、调用方只管重试，服务方保证一次和多次的请求结果是一样的。

对于第二种方案，就需要服务方的接口支持幂等性。

大致设计思路是这样的：

1. 调用接口前，先获取一个全局唯一的令牌（Token）
2. 调用接口时，将 Token 放到 Header 头中
3. 解析 Header 头，验证是否为有效 Token，无效直接返回失败
4. 完成业务逻辑后，将业务结果与 Token 进行关联存储，设置失效时间
5. 重试时不要重新获取 Token，用要上次的 Token

